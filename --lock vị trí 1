-- ‚ö° Auto Fast M1 (multi-schedule, t·ª± h·ªßy sau khi ho√†n t·∫•t)
-- M·ªói entry trong schedule = {start_seconds, end_seconds}

local FIRE_INTERVAL = 0.1 -- th·ªùi gian gi·ªØa m·ªói l·∫ßn g·ª≠i (gi√¢y)

-- üìÖ L·ªãch ho·∫°t ƒë·ªông
local schedule = {
    {13, 55},   -- b·∫≠t l√∫c 13s, t·∫Øt l√∫c 55s
    {127, 133}, -- b·∫≠t l√∫c 127s, t·∫Øt l√∫c 133s
}

-- üîç T√¨m remote: ReplicatedStorage -> BridgeNet2 -> dataRemoteEvent (fallback t√¨m descendants)
local remote
pcall(function()
    local rs = game:GetService("ReplicatedStorage")
    local bridge = rs:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(rs:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- üß± bf(): d√πng buffer.fromstring n·∫øu c√≥, fallback tr·∫£ chu·ªói th√¥
local bf = (type(buffer) == "table" and type(buffer.fromstring) == "function")
	and buffer.fromstring
	or function(s) return s end

-- üî´ Payload v√† h√†m g·ª≠i an to√†n
local payload_str = "\019\000\000\0000201000113686372022\000"
local function safeFire()
	if remote and bf then
		pcall(function()
			remote:FireServer({ { bf(payload_str) }, "\019" })
		end)
	else
		if not safeFire._warned then
			safeFire._warned = true
			warn("[Auto Fast M1] ‚ö†Ô∏è remote ho·∫∑c bf kh√¥ng kh·∫£ d·ª•ng; kh√¥ng g·ª≠i ƒë∆∞·ª£c.")
		end
	end
end

-- üïí Ch·∫°y schedule
local tick0 = tick()
local totalSchedules = #schedule
local completed = 0

for i, win in ipairs(schedule) do
	local startSec, endSec = win[1], win[2]
	local duration = endSec - startSec

	if type(startSec) ~= "number" or type(endSec) ~= "number" or duration <= 0 then
		warn(("[Auto Fast M1] Schedule #%d kh√¥ng h·ª£p l·ªá (start=%s, end=%s) ‚Äî b·ªè qua")
			:format(i, tostring(startSec), tostring(endSec)))
	else
		task.spawn(function()
			local startTime = tick0 + startSec
			local endTime = tick0 + endSec

			-- ‚è≥ Ch·ªù t·ªõi th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
			local toWait = startTime - tick()
			if toWait > 0 then task.wait(toWait) end

			if tick() >= endTime then
				warn(("[Auto Fast M1] Schedule #%d ƒë√£ tr√¥i qua ‚Äî b·ªè qua"):format(i))
				return
			end

			print(("[Auto Fast M1] #%d ‚úÖ ON (%.1fs ‚Üí %.1fs)"):format(i, startSec, endSec))

			-- üîÅ Spam trong kho·∫£ng th·ªùi gian
			while tick() < endTime do
				safeFire()
				task.wait(FIRE_INTERVAL)
			end

			print(("[Auto Fast M1] #%d üì¥ OFF (%.1fs)"):format(i, endSec))
			completed += 1

			-- üöÆ Khi t·∫•t c·∫£ schedule ƒë√£ xong ‚Üí t·ª± h·ªßy script
			if completed >= totalSchedules then
				print("[Auto Fast M1] ‚úÖ Ho√†n t·∫•t to√†n b·ªô schedule. D·ªçn d·∫πp v√† t·ª± h·ªßy script...")

				task.delay(1, function()
					-- D·ªçn s·∫°ch bi·∫øn & h√†m
					remote, bf, safeFire, schedule = nil, nil, nil, nil
					local env = getfenv()
					for k in pairs(env) do
						env[k] = nil
					end
					collectgarbage("collect")

					print("[Auto Fast M1] üßπ Script ƒë√£ ƒë∆∞·ª£c x√≥a ho√†n to√†n kh·ªèi b·ªô nh·ªõ.")
				end)
			end
		end)
	end
end
