-- Auto Spam M1 (multi schedule, standalone + auto self-destroy)
-- M·ªói entry trong schedule: {start_time, end_time}
-- => start_time: th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu (t√≠nh t·ª´ l√∫c script b·∫Øt ƒë·∫ßu)
-- => end_time: th·ªùi ƒëi·ªÉm k·∫øt th√∫c (gi√¢y)

local FIRE_INTERVAL = 0.4 -- kho·∫£ng gi·ªØa m·ªói l·∫ßn g·ª≠i (gi√¢y)

-- C√°c l·∫ßn Spam M1
local schedule = {
    {72, 76},   -- b·∫≠t l√∫c 72s, t·∫Øt l√∫c 76s
    {95, 99},   -- b·∫≠t l√∫c 95s, t·∫Øt l√∫c 99s
    {116, 120}, -- b·∫≠t l√∫c 116s, t·∫Øt l√∫c 120s
}

-- T√¨m remote: ReplicatedStorage ‚Üí BridgeNet2 ‚Üí dataRemoteEvent
local remote
pcall(function()
    local rs = game:GetService("ReplicatedStorage")
    local bridge = rs:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(rs:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- buffer handler
local bf
if type(buffer) == "table" and type(buffer.fromstring) == "function" then
    bf = buffer.fromstring
else
    bf = function(s) return s end
end

local payload_str = "\019\000\000\0000201000113686372022\000"

local function safeFire()
    if remote and bf then
        pcall(function()
            remote:FireServer({ { bf(payload_str) }, "\019" })
        end)
    else
        if not safeFire._warned then
            safeFire._warned = true
            warn("[Auto Spam M1] remote ho·∫∑c bf kh√¥ng kh·∫£ d·ª•ng; kh√¥ng g·ª≠i ƒë∆∞·ª£c.")
        end
    end
end

-- MAIN LOOP (x·ª≠ l√Ω t·ª´ng schedule)
local tick0 = tick()
local total = #schedule
local finished = 0

for i, window in ipairs(schedule) do
    local start_time, end_time = window[1], window[2]
    if type(start_time) == "number" and type(end_time) == "number" and end_time > start_time then
        task.spawn(function()
            -- ƒë·ª£i t·ªõi th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            local wait_time = tick0 + start_time - tick()
            if wait_time > 0 then task.wait(wait_time) end

            print(("[Auto Spam M1] #%d B·∫¨T (%.1fs ‚Üí %.1fs)"):format(i, start_time, end_time))

            -- spam trong kho·∫£ng th·ªùi gian ho·∫°t ƒë·ªông
            while tick() < tick0 + end_time do
                safeFire()
                task.wait(FIRE_INTERVAL)
            end

            print(("[Auto Spam M1] #%d T·∫ÆT (%.1fs)"):format(i, end_time))
            finished += 1

            -- ‚úÖ Khi t·∫•t c·∫£ schedule ho√†n th√†nh ‚Üí t·ª± xo√° script
            if finished >= total then
                print("[Auto Spam M1] ‚úÖ To√†n b·ªô schedule ƒë√£ ho√†n t·∫•t, ƒëang t·ª± d·ªçn v√† xo√° script...")

                task.delay(1, function()
                    -- D·ªçn s·∫°ch bi·∫øn trong m√¥i tr∆∞·ªùng hi·ªán t·∫°i
                    remote, bf, schedule, safeFire = nil, nil, nil, nil
                    table.clear(getfenv())
                    collectgarbage("collect")

                    print("[Auto Spam M1] üßπ Script ƒë√£ ƒë∆∞·ª£c t·ª± xo√° ho√†n to√†n kh·ªèi b·ªô nh·ªõ.")
                end)
            end
        end)
    else
        warn(("[Auto Spam M1] Schedule #%d kh√¥ng h·ª£p l·ªá (start=%s, end=%s)"):format(i, tostring(start_time), tostring(end_time)))
    end
end
