-- Auto Spam M2 (multi-window + auto self-destroy)
-- Dán vào executor — độc lập, không cần GUI hay code gốc

local FIRE_INTERVAL = 0.65 -- khoảng giữa mỗi lần gửi (giây)

-- 🕒 Danh sách các cửa sổ thời gian (giây tính từ tick0)
local schedule = {
    {13, 22},   -- bật lúc 13s, tắt lúc 22s
    {32, 41},   -- bật lúc 32s, tắt lúc 41s
    {51, 55},   -- bật lúc 51s, tắt lúc 55s
    {127, 133}, -- bật lúc 127s, tắt lúc 133s
}

-- 🔍 Tìm remote: ReplicatedStorage -> BridgeNet2 -> dataRemoteEvent
local remote
pcall(function()
    local rs = game:GetService("ReplicatedStorage")
    local bridge = rs:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(rs:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- 🔧 bf(): ưu tiên buffer.fromstring nếu có
local bf
if type(buffer) == "table" and type(buffer.fromstring) == "function" then
    bf = buffer.fromstring
else
    bf = function(s) return s end
end

-- 📦 Payload M2
local payload_str = "\019\000\000\0000201100101186595482\000"

-- 📤 Gửi yêu cầu
local function safeFire()
    if remote and bf then
        pcall(function()
            remote:FireServer({ { bf(payload_str) }, "\019" })
        end)
    else
        if not safeFire._warned then
            safeFire._warned = true
            warn("[Auto Spam M2] remote hoặc bf không khả dụng; không gửi được.")
        end
    end
end

-- 🧭 MAIN LOOP
local tick0 = tick()
local finished = 0
local totalSchedules = #schedule

for i, win in ipairs(schedule) do
    local startT, endT = win[1], win[2]
    if type(startT) ~= "number" or type(endT) ~= "number" or endT <= startT then
        warn(("[Auto Spam M2] Schedule #%d không hợp lệ (start=%s end=%s) — bỏ qua"):format(i, tostring(startT), tostring(endT)))
    else
        task.spawn(function()
            -- ⏳ Chờ tới thời điểm bắt đầu
            local waitUntil = tick0 + startT
            local toWait = waitUntil - tick()
            if toWait > 0 then task.wait(toWait) end

            if tick() >= tick0 + endT then
                warn(("[Auto Spam M2] Schedule #%d đã trôi qua trước khi bắt đầu — bỏ qua."):format(i))
                finished += 1
                return
            end

            print(("[Auto Spam M2] Schedule #%d 🟢 BẬT (%.1fs → %.1fs)"):format(i, startT, endT))

            -- 🔁 Gửi liên tục trong khoảng thời gian
            while tick() < tick0 + endT do
                safeFire()
                task.wait(FIRE_INTERVAL)
            end

            print(("[Auto Spam M2] Schedule #%d 🔴 TẮT (%.1fs)"):format(i, endT))

            -- 🧹 Kiểm tra nếu tất cả đã hoàn thành
            finished += 1
            if finished >= totalSchedules then
                print("[Auto Spam M2] ✅ Tất cả schedule đã hoàn thành. Đang tự dọn và xoá script...")

                task.delay(1, function()
                    remote, bf, safeFire, schedule = nil, nil, nil, nil
                    table.clear(getfenv())
                    collectgarbage("collect")
                    print("[Auto Spam M2] 🧹 Script đã được tự xoá hoàn toàn khỏi bộ nhớ.")
                end)
            end
        end)
    end
end
