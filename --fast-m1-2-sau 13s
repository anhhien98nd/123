-- Auto Fast M1 (multi-schedule, standalone)
-- Mỗi entry trong `schedule` = {start_seconds, duration_seconds} (tính từ lúc script bắt đầu)
-- Ví dụ: {13,54} nghĩa là bắt đầu ở 13s, chạy 54s (kết thúc ở 67s)

local FIRE_INTERVAL = 0.1 -- khoảng cách giữa mỗi lần gửi (giây)

-- đặt lịch: thêm {13,54} (bản cũ) và {92,96} (bạn yêu cầu)
local schedule = {
    {13, 54},  -- start 13s, duration 54s  -> end = 67s
    {92, 96},  -- start 92s, duration 96s  -> end = 188s
}

-- tìm remote: ReplicatedStorage -> BridgeNet2 -> dataRemoteEvent (fallback tìm descendants)
local remote
pcall(function()
    local rs = game:GetService("ReplicatedStorage")
    local bridge = rs:FindFirstChild("BridgeNet2")
    if bridge then
        remote = bridge:FindFirstChild("dataRemoteEvent")
    end
    if not remote then
        for _, v in ipairs(rs:GetDescendants()) do
            if v.Name == "dataRemoteEvent" then
                remote = v
                break
            end
        end
    end
end)

-- bf(): ưu tiên buffer.fromstring nếu có, fallback trả chuỗi thô
local bf
if type(buffer) == "table" and type(buffer.fromstring) == "function" then
    bf = buffer.fromstring
else
    bf = function(s) return s end
end

local payload_str = "\019\000\000\0000201000113686372022\000"

local function safeFire()
    if remote and bf then
        pcall(function()
            remote:FireServer({ { bf(payload_str) }, "\019" })
        end)
    else
        if not safeFire._warned then
            safeFire._warned = true
            warn("[Auto Fast M1] remote hoặc bf không khả dụng; không gửi được.")
        end
    end
end

-- scheduling
local tick0 = tick()

for i, win in ipairs(schedule) do
    local startSec, duration = win[1], win[2]
    if type(startSec) ~= "number" or type(duration) ~= "number" or duration <= 0 then
        warn(("[Auto Fast M1] Schedule #%d không hợp lệ (start=%s, duration=%s) — bỏ qua"):format(i, tostring(startSec), tostring(duration)))
    else
        task.spawn(function()
            local startTime = tick0 + startSec
            local endTime = startTime + duration

            -- chờ đến thời điểm bắt đầu
            local toWait = startTime - tick()
            if toWait > 0 then task.wait(toWait) end

            -- nếu đã vượt quá endTime, bỏ qua
            if tick() >= endTime then
                warn(("[Auto Fast M1] Schedule #%d đã trôi qua trước khi bắt đầu — bỏ qua"):format(i))
                return
            end

            print(("[Auto Fast M1] Schedule #%d ON (%.1fs -> %.1fs)"):format(i, startSec, startSec + duration))

            -- spam trong cửa sổ thời gian
            while tick() < endTime do
                safeFire()
                task.wait(FIRE_INTERVAL)
            end

            print(("[Auto Fast M1] Schedule #%d OFF (kết thúc %.1fs)"):format(i, startSec + duration))
        end)
    end
end
